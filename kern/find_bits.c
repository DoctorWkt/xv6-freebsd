#include <xv6/find_bits.h>

unsigned long
find_next_zero_bit(const unsigned long *addr, unsigned long size,
    unsigned long offset)
{
  const unsigned long *p = addr + BITOP_WORD(offset);
  unsigned long result = offset & ~(BITS_PER_LONG-1);
  unsigned long tmp;

  if (offset >= size)
    return size;
  size -= result;
  offset %= BITS_PER_LONG;
  if (offset) {
    tmp = *(p++);
    tmp |= ~0UL >> (BITS_PER_LONG - offset);
    if (size < BITS_PER_LONG)
      goto found_first;
    if (~tmp)
      goto found_middle;
    size -= BITS_PER_LONG;
    result += BITS_PER_LONG;
  }
  while (size & ~(BITS_PER_LONG-1)) {
    if (~(tmp = *(p++)))
      goto found_middle;
    result += BITS_PER_LONG;
    size -= BITS_PER_LONG;
  }
  if (!size)
    return result;
  tmp = *p;

found_first:
  tmp |= ~0UL << size;
  if (tmp == ~0UL)/* Are any bits zero? */
    return result + size;   /* Nope. */
found_middle:
  return result + ffz(tmp);
}

